// Информативный комментарий
import random
list100 = [] # формируем массив
n = 100 # размер массива
for i in range(n):
    list100.append(random.randint(1,50))
for j in range(n//2):
# перестановка местами первого и последнего элемента списка
    x = list100[99-j]
    list100[99-j] = list100[j]
    list100[j] = x

// Информативный комментарий
x = [] # создаём массив
summ = 0 # создаём переменную для подсчёта суммы
import random # подключаем модуль работы со случайными величинами
for i in range(100): 
    x.append(random.randint(1,50))
max = x[0] # предварительное максимальное значение
min = x[0] # предварительное максимальное значение
...

// Информативный комментарий
# код для рисования узора
x = 1 # задаём переменную для вывода количества звёздочек на одной строке
for j in range(9): # задаём цикл для вывода очередной строки
    for i in range(x): # задаём цикл для вывода звёздочек
        print("*", end='')
    ...

// TODO
#TODO - убрать N из параметров и высчитывать самостоятельно либо добавить проверку на принадлежание границам массива - 6
def SumOfThe(N, data):
    …

// Предупреждение о последствиях
#Не используйте N != len(hits), иначе программа может завершится с исключением out of range либо некорректно обработать данные
def PatternUnlock(N, hits):
    …

// Усиление
...
#Только с удерживаемых полей возможен захват соседних территорий. С недавно захваченных полей захват соседних клеток невозможен
if squares[n][m] == 2:
...

// TODO
# в этом словаре хранится таблица подстановки символов
# TODO - вынести словарь в отдельный модуль
d = {' ': 0, '&': 24, ',': 7, '2': 22, '8': 23, '>': 10, 'D': 26,
    ...

// Информативный комментарий
def MadMax(N: int, Tele: list) -> list:
    # ОБЯЗАТЕЛЬНАЯ проверка равенства N и длины массива
    # если равенства нет, то функция отработает с ошибкой
    if N != len(Tele):
        return [0, 0, 0]

// Предупреждение о последствиях
# НЕ УДАЛЯЙТЕ этот модуль
# он используется в двух местах в расчете программы
def min3(a, b, c):
    if a <= b and a <= c:
        return a
    if b <= c:
        return b
    return c

// Информативный комментарий
def BigMinus(s1: str, s2: str) -> str:
    # проверяем соотвествие друг другу входные переменные
    # не удалять первую проверку, можем получить исключение
    if s1 == s2:
        return '0'
    ...

// TODO
#TODO - добавить возможность перевода в двоичную систему счисления - 6
def UFO(N, data, octal):
    …

// Предупреждение о последствиях
#НЕ ИСПОЛЬЗУЙТЕ N != len(hits), иначе программа может завершится с исключением out of range либо некорректно обработать данные
def PatternUnlock(N, hits):
